// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   @discordjs/voice
//   ytdl-core
//   soundcloud-downloader
//   tiny-typed-emitter
//   prism-media
//   stream
//   fs/promises
//   axios
//   m3u8stream
//   soundcloud-downloader/src/info
//   youtube-scrapper

declare module 'discord-media-player' {
    /**
        * The current installed version of the package
        */
    export const version: string;
    export * from "discord-media-player/dist/audio/AudioManager";
    export * from "discord-media-player/dist/audio/AudioPlayer";
    export * from "discord-media-player/dist/audio/AudioPlayerImpl";
    export * from "discord-media-player/dist/cache/Cache";
    export * from "discord-media-player/dist/cache/CacheManager";
    export * from "discord-media-player/dist/cache/CacheManagerImpl";
    export * from "discord-media-player/dist/cache/CacheWriter";
    export * from "discord-media-player/dist/cache/CacheReader";
    export * from "discord-media-player/dist/cache/PacketReader";
    import * as _ErrorCode from "discord-media-player/dist/util/ErrorCode";
    import * as _Filters from "discord-media-player/dist/util/Filters";
    import * as _noop from "discord-media-player/dist/util/noop";
    import * as _Resource from "discord-media-player/dist/util/Resource";
    import * as _Skipper from "discord-media-player/dist/util/Skipper";
    import * as _SourceType from "discord-media-player/dist/util/SourceType";
    /**
        * Package helper utility
        */
    export namespace Util {
            export import ErrorCode = _ErrorCode.ErrorCode;
            export import Filters = _Filters.Filters;
            export import noop = _noop.noop;
            export import Resource = _Resource.Resource;
            export import ResourceOptions = _Resource.ResourceOptions;
            export import Skipper = _Skipper.Skipper;
            export import SourceType = _SourceType.SourceType;
    }
    import * as _downloadMedia from "discord-media-player/dist/soundcloudUtil/downloadMedia";
    import * as _transcoding from "discord-media-player/dist/soundcloudUtil/transcoding";
    import * as _util from "discord-media-player/dist/soundcloudUtil/util";
    /**
        * Soundcloud (soundcloud-downloader) utility
        *
        * Copied from "https://www.npmjs.com/package/soundcloud-downloader"
        */
    export namespace SoundcloudUtil {
            export import downloadMedia = _downloadMedia.downloadMedia;
            export import appendURL = _util.appendURL;
            export import handleRequestErrs = _util.handleRequestErrs;
            export import validateMedia = _util.validateMedia;
            export import FORMATS = _transcoding.FORMATS;
            export import STREAMING_PROTOCOLS = _transcoding.STREAMING_PROTOCOLS;
            export import Transcoding = _transcoding.Transcoding;
    }
    export * as ValidationUtil from "discord-media-player/dist/validation";
    export * from "discord-media-player/dist/queue";
}

declare module 'discord-media-player/dist/audio/AudioManager' {
    import type { ErrorCode } from "discord-media-player/dist/util/ErrorCode";
    import type { CacheManager } from "discord-media-player/dist/cache/CacheManager";
    import type { VoiceConnection } from "@discordjs/voice";
    import type { downloadOptions } from "ytdl-core";
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    import SCDL from "soundcloud-downloader";
    import { TypedEmitter } from "tiny-typed-emitter";
    type createAudioPlayerType = () => AudioPlayer;
    /**
        * The options for AudioManager
        */
    export interface AudioManagerOptions {
            /**
                * The audio cache manager
                */
            cache?: CacheManager;
            /**
                * The directory where the audio cache is saved
                */
            cacheDir?: string;
            /**
                * The timeout for cache deletion (in ms)
                */
            cacheTimeout?: number;
            /**
                * Abort the player after reaching timeout on buffering (in ms), default to 7 seconds
                */
            playTimeout?: number;
            /**
                * The downloadOptions (ytdl-core) when getting audio source from youtube
                */
            youtubeOptions?: downloadOptions;
            /**
                * The soundcloud client (soundcloud-downloader) when getting audio source from soundcloud
                */
            soundcloudClient?: typeof SCDL;
            /**
                * Custom method for creating audio player implementation
                */
            createAudioPlayer?: createAudioPlayerType;
    }
    export interface AudioManagerEvents {
            /**
                * @param guildID The guildID of the linked connection in player
                * @param urlOrLocation The audio url or location
                */
            audioStart(guildID: string, urlOrLocation: string): void;
            /**
                * @param guildID The guildID of the linked connection in player
                * @param urlOrLocation The audio url or location
                */
            audioEnd(guildID: string, urlOrLocation: string): void;
            /**
                * @param guildID The guildID of the linked connection in player
                * @param urlOrLocation The audio url or location
                * @param errorCode The error code to identify error
                */
            audioError(guildID: string, urlOrLocation: string, errorCode: ErrorCode): void;
    }
    /**
        * The manager of the audio players
        */
    export class AudioManager extends TypedEmitter<AudioManagerEvents> {
            /**
                * Emitted whenever an audio is started playing
                *
                * Listener must implement {@link AudioManagerEvents.audioStart | AudioStartCallback}
                * @event
                */
            static AUDIO_START: string;
            /**
                * Emitted whenever an audio is ended after playing
                *
                * Listener must implement {@link AudioManagerEvents.audioEnd | AudioEndCallback}
                * @event
                */
            static AUDIO_END: string;
            /**
                * Emitted whenever an error is thrown while getting audio source before playing
                *
                * Listener must implement {@link AudioManagerEvents.audioError | AudioErrorCallback}
                * @event
                */
            static AUDIO_ERROR: string;
            /**
                * The audio cache manager
                */
            readonly cache?: CacheManager;
            /**
                * Abort the player after reaching timeout on buffering (in ms), default to 7 seconds
                */
            readonly playTimeout?: number;
            /**
                * The soundcloud client (soundcloud-downloader) when getting audio source
                */
            readonly soundcloud: typeof SCDL;
            /**
                * The downloadOptions (ytdl-core) when getting audio source
                */
            readonly youtube: downloadOptions;
            /**
                * @param options The options to create new audio player manager
                */
            constructor(options: AudioManagerOptions);
            /**
                * Get player from list if exist, otherwise create new
                * @param connection The voice connection
                * @returns The audio player
                */
            getPlayer(connection: VoiceConnection): AudioPlayer;
            /**
                * Delete player from list and unlink it
                * @param connection The voice connection
                * @returns false if failed or doesn't exist, true if deleted
                */
            deletePlayer(connection: VoiceConnection): boolean;
            /**
                * @internal
                */
            _deletePlayerIfExist(guildID: string): void;
    }
    export {};
}

declare module 'discord-media-player/dist/audio/AudioPlayer' {
    import type { Filters } from "discord-media-player/dist/util/Filters";
    import type { AudioManager } from "discord-media-player/dist/audio/AudioManager";
    import type { TypedEmitter } from "tiny-typed-emitter";
    import type { VoiceConnection, AudioPlayerStatus } from "@discordjs/voice";
    export interface PlayerEvents {
            unlink(): void;
            pause(): void;
            unpause(): void;
            end(): void;
    }
    /**
        * The instance to manage and play audio to discord
        */
    export interface AudioPlayer extends TypedEmitter<PlayerEvents> {
            /**
                * The manager of the audio player
                */
            manager: AudioManager;
            /**
                * The linked connection guild id
                */
            guildID: string;
            /**
                * The discord player status
                */
            status: AudioPlayerStatus;
            /**
                * Whether or not the audio player is playing audio.
                */
            playing: boolean;
            /**
                * For how long this player has been playing audio (in ms)
                */
            playbackDuration: number;
            /**
                * Set the manager of the audio player
                * @param manager The audio manager
                */
            setManager(manager: AudioManager): void;
            /**
                * Link the voice connection to the audio player
                * @param connection The voice connection
                */
            link(connection: VoiceConnection): void;
            /**
                * Unlink the audio player from the previous voice connection
                */
            unlink(): void;
            /**
                * Set filters into the audio player
                * @param filter The filters
                */
            setFilter(filter?: Filters): void;
            /**
                * Set volume of the audio
                * @param volume The volume
                */
            setVolume(volume: number): void;
            /**
                * Stop the audio
                */
            stop(): boolean;
            /**
                * Loop the audio
                */
            loop(): boolean;
            /**
                * Pause the audio
                */
            pause(forcePauseUnpause?: boolean): boolean;
            /**
                * Filter the audio
                */
            filter(): void;
            /**
                * Seek the audio
                * @param seconds The position to seek to
                */
            seek(seconds: number): Promise<void>;
            /**
                * Play an audio
                * @param urlOrLocation The url or location of the audio source
                * @param sourceType The source type to identify the source
                */
            play(urlOrLocation: string, sourceType: number): Promise<void>;
            /**
                * Switch to playing cache instead of resource
                *
                * This method must not be used by user directly,
                * it is used for custom player implementation to work
                * with cache
                */
            _switchCache(): void;
    }
}

declare module 'discord-media-player/dist/audio/AudioPlayerImpl' {
    import type { Filters } from "discord-media-player/dist/util/Filters";
    import type { AudioManager } from "discord-media-player/dist/audio/AudioManager";
    import type { SourceType } from "discord-media-player/dist/util/SourceType";
    import type { AudioPlayer, PlayerEvents } from "discord-media-player/dist/audio/AudioPlayer";
    import type { VoiceConnection } from "@discordjs/voice";
    import { AudioPlayerStatus } from "@discordjs/voice";
    import { TypedEmitter } from "tiny-typed-emitter";
    /**
        * The default implementation of {@link AudioPlayer | AudioPlayer}
        */
    export class AudioPlayerImpl extends TypedEmitter<PlayerEvents> implements AudioPlayer {
            /**
                * Emitted when player is unlinked from connection
                * @event
                */
            static UNLINK: string;
            /**
                * Emitted whenever player is paused
                * @event
                */
            static PAUSE: string;
            /**
                * Emitted whenever player is unpaused
                * @event
                */
            static UNPAUSE: string;
            /**
                * Emitted whenever an audio is ended
                * @event
                */
            static END: string;
            /**
                * @internal
                */
            manager: AudioManager;
            /**
                * @internal
                */
            constructor();
            /**
                * @internal
                */
            get guildID(): string;
            /**
                * @internal
                */
            get status(): AudioPlayerStatus;
            /**
                * @internal
                */
            get playing(): boolean;
            /**
                * @internal
                */
            get playbackDuration(): number;
            /**
                * @internal
                */
            setManager(manager: AudioManager): void;
            /**
                * @internal
                */
            link(connection: VoiceConnection): void;
            /**
                * @internal
                */
            unlink(): void;
            /**
                * @internal
                */
            setFilter(filter: Filters): void;
            /**
                * @internal
                */
            setVolume(volume: number): void;
            /**
                * @internal
                */
            stop(): boolean;
            /**
                * @internal
                */
            loop(): boolean;
            /**
                * @internal
                */
            pause(pauseOrUnpause?: boolean): boolean;
            /**
                * @internal
                */
            filter(): void;
            /**
                * @internal
                */
            seek(seconds: number): Promise<void>;
            /**
                * @internal
                */
            play(urlOrLocation: string, sourceType: SourceType): Promise<void>;
            /**
                * @internal
                */
            _switchCache(): void;
    }
}

declare module 'discord-media-player/dist/cache/Cache' {
    import type { Resource } from "discord-media-player/dist/util/Resource";
    import { opus } from "prism-media";
    import { CacheReader } from "discord-media-player/dist/cache/CacheReader";
    /**
        * The options for cache instance
        */
    export interface CacheOptions {
            path?: string;
            timeout?: number;
    }
    /**
        * The cache instance to manage cache for a source
        */
    export class Cache {
            /**
                * The timeout for deleting cache after inactivity
                */
            timeout: number;
            /**
                * @param dir The directory of the cache
                */
            constructor(dir: string);
            /**
                * The full path of base directory and directory
                */
            get path(): string;
            /**
                * Set the options for cache
                * @param options The cache options
                */
            setOptions(options: CacheOptions): void;
            /**
                * Create a new cache
                * @param identifier The audio identifier
                * @param resource The audio resource
                * @returns The OpusEncoder stream to compress and write cache
                */
            create(identifier: string, resource: Resource): opus.Encoder;
            /**
                * Read an existing cache
                * @param identifier The audio identifier
                * @param startOnSeconds Start reading cache on specific second of audio
                * @returns The OpusDecoder stream of audio
                */
            read(identifier: string, startOnSeconds?: number): opus.Decoder;
            /**
                * Check if cache exist
                * @param identifier The audio identifier
                * @returns true if exist, otherwise false
                */
            hasCache(identifier: string): boolean;
            /**
                * Get the audio resource from an existing cache
                * @param identifier The audio identifier
                * @returns The audio resource
                */
            getResource(identifier: string): Resource;
            /**
                * Get the cache reader of decoder from cache
                * @param decoder The opus decoder
                * @returns The cache reader
                */
            getReader(decoder: opus.Decoder): CacheReader;
    }
}

declare module 'discord-media-player/dist/cache/CacheManager' {
    import type { Cache } from "discord-media-player/dist/cache/Cache";
    export interface CacheManager {
            /**
                * The base directory of the caches
                */
            path: string;
            /**
                * The timeout for deleting cache after inactivity
                */
            timeout: number;
            /**
                * Audio cache from youtube source
                */
            readonly youtube: Cache;
            /**
                * Audio cache from soundcloud source
                */
            readonly soundcloud: Cache;
            /**
                * Audio cache from local source
                */
            readonly local: Cache;
            /**
                * Set the cache deletion timeout of the caches
                * @param timeout The cache timeout
                */
            setTimeout(timeout: number): void;
            /**
                * Set the base directory of the caches
                * @param path The base directory
                */
            setPath(path: string): void;
            /**
                * A function to force delete cache directory
                */
            delete?(): void | Promise<void>;
    }
}

declare module 'discord-media-player/dist/cache/CacheManagerImpl' {
    import type { CacheManager } from "discord-media-player/dist/cache/CacheManager";
    import { Cache } from "discord-media-player/dist/cache/Cache";
    /**
        * The default implementation of {@link CacheManager | CacheManager}
        */
    export class CacheManagerImpl implements CacheManager {
            /**
                * @internal
                */
            path: string;
            /**
                * @internal
                */
            timeout: number;
            /**
                * @internal
                */
            readonly youtube: Cache;
            /**
                * @internal
                */
            readonly soundcloud: Cache;
            /**
                * @internal
                */
            readonly local: Cache;
            /**
                * @internal
                */
            readonly deleter: import("child_process").ChildProcess;
            /**
                * @internal
                */
            constructor();
            /**
                * @internal
                */
            setTimeout(timeout: number): void;
            /**
                * @internal
                */
            setPath(path: string): void;
            /**
                * @internal
                */
            delete(): Promise<void>;
    }
}

declare module 'discord-media-player/dist/cache/CacheWriter' {
    import type { opus } from "prism-media";
    import type { Resource } from "discord-media-player/dist/util/Resource";
    import type { TransformCallback } from "stream";
    import { Transform } from "stream";
    /**
        * The instance to write audio into cache
        */
    export class CacheWriter extends Transform {
            /**
                * The cache OpusEncoder stream
                */
            get writeStream(): opus.Encoder;
            /**
                * Set the audio resource
                * @param resource The audio resource
                */
            setResource(resource: Resource): void;
            /**
                * @internal
                */
            _transform(chunk: Buffer, _: BufferEncoding, cb: TransformCallback): void;
            /**
                * @internal
                */
            _flush(cb: TransformCallback): void;
            /**
                * @internal
                */
            pipe<T extends NodeJS.WritableStream>(destination: T, options?: {
                    end?: boolean;
            }): T;
            /**
                * @internal
                */
            unpipe<T extends NodeJS.WritableStream>(destination?: T): this;
    }
}

declare module 'discord-media-player/dist/cache/CacheReader' {
    import type { Packet } from "discord-media-player/dist/cache/PacketReader";
    import type { FileHandle } from "fs/promises";
    import { Readable } from "stream";
    /**
        * An instance to appropriately read opus packet
        */
    export class CacheReader extends Readable {
            /**
                * How many packets has been read (in ms)
                */
            packetRead: number;
            /**
                * @param packets The array of packets
                * @param file The file to read
                * @param ms Where to start reading (in ms)
                */
            constructor(packets: Array<Packet>, file: Promise<FileHandle>, ms: number);
            /**
                * @internal
                */
            _read(): Promise<void>;
    }
}

declare module 'discord-media-player/dist/cache/PacketReader' {
    import type { TransformCallback } from "stream";
    import { Transform } from "stream";
    /**
        * The metadata of packets including packet size and packet frames count
        */
    export interface Packet {
            size: number;
            frames: number;
    }
    /**
        * An instance to mark the packet size and frames in packet
        */
    export class PacketReader extends Transform {
            /**
                * @param packets The allocated array of packets
                */
            constructor(packets: Array<Packet>);
            /**
                * @internal
                */
            _transform(packet: Buffer, _: BufferEncoding, cb: TransformCallback): void;
    }
}

declare module 'discord-media-player/dist/util/ErrorCode' {
    /**
      * The error codes of audio player
      */
    export enum ErrorCode {
        noFormatOrMedia = 0,
        cannotOpenFile = 1,
        youtubeNoPlayerResponse = 2,
        youtubeUnplayable = 3,
        youtubeLoginRequired = 4,
        noResource = 5,
        timedOut = 6
    }
}

declare module 'discord-media-player/dist/util/Filters' {
    /**
      * https://ffmpeg.org/ffmpeg-filters.html#Audio-Filters
      *
      * { filterName: "filterValue" }
      *
      * Leave "filterValue" as blank "", if no value
      */
    export interface Filters {
        acompressor?: string;
        aconstrast?: string;
        acrossfade?: string;
        acrossover?: string;
        acrusher?: string;
        adeclick?: string;
        adeclip?: string;
        adelay?: string;
        adenorm?: string;
        aecho?: string;
        aemphasis?: string;
        aexciter?: string;
        afade?: string;
        afftdn?: string;
        afftfilt?: string;
        afir?: string;
        afreqshift?: string;
        agate?: string;
        aiir?: string;
        allpass?: string;
        anequalizer?: string;
        anlmdn?: string;
        apad?: string;
        aphaser?: string;
        aphaseshift?: string;
        apulsator?: string;
        aresample?: string;
        arnndn?: string;
        asetnsamples?: string;
        asetrate?: string;
        asoftclip?: string;
        asubbost?: string;
        asubcut?: string;
        asupercut?: string;
        asuperpass?: string;
        asuperstop?: string;
        atempo?: string;
        bandpass?: string;
        bandreject?: string;
        bass?: string;
        biquad?: string;
        chorus?: string;
        compand?: string;
        compensationdelay?: string;
        crossfeed?: string;
        crystalizer?: string;
        dcshift?: string;
        deesser?: string;
        dynaudnorm?: string;
        earwax?: string;
        equalizer?: string;
        extrastereo?: string;
        firequalizer?: string;
        flanger?: string;
        haas?: string;
        headphone?: string;
        highpass?: string;
        highshelf?: string;
        loudnorm?: string;
        lowpass?: string;
        lowshelf?: string;
        mcompand?: string;
        silenceremove?: string;
        speechnorm?: string;
        stereowiden?: string;
        superequalizer?: string;
        surround?: string;
        treble?: string;
        vibrato?: string;
    }
}

declare module 'discord-media-player/dist/util/noop' {
    /**
      * Empty function (NO-OP)
      */
    export function noop(): void;
}

declare module 'discord-media-player/dist/util/Resource' {
    import type { Cache } from "discord-media-player/dist/cache/Cache";
    import type { CacheWriter } from "discord-media-player/dist/cache/CacheWriter";
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    import type { Readable, Transform, Duplex } from "stream";
    /**
        * Options for making audio resource
        */
    export interface ResourceOptions {
            /**
                * The audio player that create the audio resource
                */
            player: AudioPlayer;
            /**
                * The audio identifier
                */
            identifier: string;
            /**
                * The audio decoder
                */
            decoder: Transform | Duplex;
            /**
                * The audio source
                */
            source: Readable;
            /**
                * The audio cache writer
                */
            cacheWriter: CacheWriter;
            /**
                * The cache instance of audio source
                */
            cache?: Cache;
            /**
                * true if the audio source is livestream, otherwise false
                */
            isLive?: boolean;
            /**
                * The audio demuxer
                */
            demuxer?: Transform;
    }
    /**
        * The audio resource instance
        */
    export class Resource {
            /**
                * The audio cached in seconds
                */
            cachedSecond: number;
            /**
                * true if all audio is cached, otherwise false
                */
            allCached: boolean;
            /**
                * true if the audio source is livestream, otherwise false
                */
            readonly isLive: boolean;
            /**
                * The audio identifier
                */
            readonly identifier: string;
            /**
                * The audio decoder
                */
            readonly decoder: Transform | Duplex;
            /**
                * The audio source
                */
            readonly source: Readable;
            /**
                * The cache instance of audio source
                */
            readonly cache?: Cache;
            /**
                * The audio demuxer
                */
            readonly demuxer?: Transform;
            /**
                * The audio cache writer
                */
            readonly cacheWriter?: CacheWriter;
            /**
                * @param options The options to create audio resource
                */
            constructor(options: ResourceOptions);
            set player(player: AudioPlayer);
            get player(): AudioPlayer;
            set autoPaused(paused: boolean);
            get autoPaused(): boolean;
    }
}

declare module 'discord-media-player/dist/util/Skipper' {
    import type { CacheWriter } from "discord-media-player/dist/cache/CacheWriter";
    import { Writable } from "stream";
    /**
        * The instance for skipping the audio
        */
    export class Skipper extends Writable {
            /**
                * @param seconds The amount to skip in second
                * @param _cacheWriter The audio cache writer
                */
            constructor(seconds: number, _cacheWriter: CacheWriter);
            /**
                * @internal
                */
            _write(chunk: Buffer, _: BufferEncoding, cb: () => void): void;
            /**
                * @internal
                */
            _final(cb: () => void): void;
    }
}

declare module 'discord-media-player/dist/util/SourceType' {
    /**
      * The source type of the audio source
      */
    export enum SourceType {
        youtube = 0,
        soundcloud = 1,
        local = 2
    }
}

declare module 'discord-media-player/dist/soundcloudUtil/downloadMedia' {
    import type { AxiosInstance } from "axios";
    import type { Transcoding } from "discord-media-player/dist/soundcloudUtil/transcoding";
    import type { Readable } from "stream";
    import m3u8stream from "m3u8stream";
    /**
      * Download a specific media transcoding from soundcloud
      * @param media The audio media transcoding
      * @param clientID The soundcloud client id
      * @param axiosInstance The axios instance
      * @returns The audio source stream
      *
      * Copied from "https://www.npmjs.com/package/soundcloud-downloader"
      */
    export function downloadMedia(media: Transcoding, clientID: string, axiosInstance: AxiosInstance): Promise<Readable | m3u8stream.Stream>;
}

declare module 'discord-media-player/dist/soundcloudUtil/transcoding' {
    /**
        * The streaming protocols (protocol) of media transcoding
        *
        * Copied from "https://www.npmjs.com/package/soundcloud-downloader"
        */
    export enum STREAMING_PROTOCOLS {
            HLS = "hls",
            PROGRESSIVE = "progressive"
    }
    /**
        * The format (mime_type) of media transcoding
        *
        * Copied from "https://www.npmjs.com/package/soundcloud-downloader"
        */
    export enum FORMATS {
            MP3 = "audio/mpeg",
            OPUS = "audio/ogg; codecs=\"opus\""
    }
    /**
        * The interface of media transcoding
        *
        * Copied from "https://www.npmjs.com/package/soundcloud-downloader"
        */
    export interface Transcoding {
            url: string;
            preset: string;
            snipped: boolean;
            format: {
                    protocol: STREAMING_PROTOCOLS;
                    mime_type: FORMATS;
            };
    }
}

declare module 'discord-media-player/dist/soundcloudUtil/util' {
    import type { AxiosError } from "axios";
    import type { Transcoding } from "discord-media-player/dist/soundcloudUtil/transcoding";
    /**
        * Handle axios error
        * @param err The axios error
        * @returns The handle'd axios error
        *
        * Copied from "https://www.npmjs.com/package/soundcloud-downloader"
        */
    export function handleRequestErrs(err: AxiosError): AxiosError;
    /**
        * Append parameters into url
        * @param baseURL The base url
        * @param params The parameters
        * @returns The appended url
        *
        * Copied from "https://www.npmjs.com/package/soundcloud-downloader"
        */
    export function appendURL(baseURL: string, ...params: string[]): string;
    /**
        * Validate the media transcoding
        * @param media The media transcoding
        * @returns true if valid, otherwise false
        *
        * Copied from "https://www.npmjs.com/package/soundcloud-downloader"
        */
    export function validateMedia(media: Transcoding): boolean;
}

declare module 'discord-media-player/dist/validation' {
    export * from "discord-media-player/dist/validation/PlayerError";
    export * as AudioManagerValidation from "discord-media-player/dist/validation/ManagerValidation";
    export * as AudioPlayerValidation from "discord-media-player/dist/validation/PlayerValidation";
    export * as CacheValidation from "discord-media-player/dist/validation/CacheValidation";
    export * as CacheManagerValidation from "discord-media-player/dist/validation/CacheManagerValidation";
    export * as CacheWriterValidation from "discord-media-player/dist/validation/CacheWriterValidation";
    export * as ResourceValidation from "discord-media-player/dist/validation/ResourceValidation";
    export * as SkipperValidation from "discord-media-player/dist/validation/SkipperValidation";
    export * as QueueManagerValidation from "discord-media-player/dist/validation/QueueManagerValidation";
    export * as QueueHandlerValidation from "discord-media-player/dist/validation/QueueHandlerValidation";
    export * as QueueValidation from "discord-media-player/dist/validation/QueueValidation";
    export * as TrackValidation from "discord-media-player/dist/validation/TrackValidation";
    export * as PacketReaderValidation from "discord-media-player/dist/validation/PacketReaderValidation";
    export * as CacheReaderValidation from "discord-media-player/dist/validation/CacheReaderValidation";
}

declare module 'discord-media-player/dist/queue' {
    export * from "discord-media-player/dist/queue/QueueManager";
    export * from "discord-media-player/dist/queue/QueueHandler";
    export * from "discord-media-player/dist/queue/Queue";
    export * from "discord-media-player/dist/queue/Track";
}

declare module 'discord-media-player/dist/validation/PlayerError' {
    /**
        * Validate the error of PlayerError
        * @param error The error
        */
    export function validateError(error: ErrorType): void;
    /**
        * THe error interface of PlayerError
        */
    export interface ErrorType {
            /**
                * The message of the error
                */
            message: string;
            /**
                * Error code of the error
                *
                * 0-99 For built-in player error
                *
                * 100-??? for custom player error
                */
            code: number;
    }
    /**
        * Available built-in error messages for PlayerError
        */
    export namespace ErrorMessages {
            /**
                * Error when value is different than expected
                * @param expecting THe expected value
                * @param where Where does the error take place
                * @param got The actual value
                * @returns The error
                */
            function Expecting(expecting: string | string[], where: string, got: unknown): ErrorType;
            /**
                * Error when key is not exist in an object
                * @param what The key that expected to exist in the object
                * @param where Where does the error take place
                * @returns The error
                */
            function NotProvided(what: string, where: string): ErrorType;
            /**
                * Error when value is a number but not an integer
                * @param what The value that supposed to be integer
                * @returns The error
                */
            function NotInteger(what: number): ErrorType;
            /**
                * Error when value doesn't have any of the thing
                * @param what The value that must have the thing
                * @param things Some thing that must be on the value atleast one of it
                * @returns The error
                */
            function AtleastHave(what: string, things: string[]): ErrorType;
            /**
                * Error when value is not a valid source type
                * @param sourceType The source type
                * @returns The error
                */
            function NotValidSourceType(sourceType: number): ErrorType;
            /**
                * Error when player is already linked
                */
            const PlayerAlreadyLinked: ErrorType;
            /**
                * Error when player is not linked
                */
            const PlayerNotLinked: ErrorType;
            /**
                * Error when player is already playing
                */
            const PlayerAlreadyPlaying: ErrorType;
            /**
                * Error when player is not playing
                */
            const PlayerNotPlaying: ErrorType;
            /**
                * Error when cache with the provided identifier already exist
                * @param identifier The cache identifier
                * @returns The error
                */
            function CacheAlreadyExist(identifier: string): ErrorType;
            /**
                * Error when cache with the provided identifier doesn't exist
                * @param identifier The cache identifier
                * @returns The error
                */
            function CacheNotExist(identifier: string): ErrorType;
            /**
                * Error when queue is empty while trying to start queue cycle
                */
            const QueueEmpty: ErrorType;
    }
    /**
        * Custom error for discord-media-player
        */
    export class PlayerError extends Error {
            /**
                * @internal
                */
            errorCode: number;
            /**
                * @param error The error
                */
            constructor(error: ErrorType);
            /**
                * The error code
                */
            get code(): number;
    }
}

declare module 'discord-media-player/dist/validation/ManagerValidation' {
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    import type { AudioManagerOptions } from "discord-media-player/dist/audio/AudioManager";
    import { VoiceConnection } from "@discordjs/voice";
    /**
        * Validate the audio manager options
        * @param options The audio manager options
        */
    export function validateOptions(options: AudioManagerOptions): void;
    /**
        * Validate the voice connection
        * @param connection The voice connection
        */
    export function validateConnection(connection: VoiceConnection): void;
    /**
        * Validate the audio player
        * @param player The audio player
        */
    export function validatePlayer(player: AudioPlayer): void;
}

declare module 'discord-media-player/dist/validation/PlayerValidation' {
    import type { Filters } from "discord-media-player/dist/util/Filters";
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    import { AudioManager } from "discord-media-player/dist/audio/AudioManager";
    import { VoiceConnection } from "@discordjs/voice";
    /**
        * Validate the audio manager
        * @param manager The audio manager
        */
    export function validateManager(manager: AudioManager): void;
    /**
        * Validate the voice connection
        * @param connection The voice connection
        */
    export function validateConnection(connection: VoiceConnection): void;
    /**
        * Validate the audio filters
        * @param filter The audio filters
        */
    export function validateFilters(filter?: Filters): void;
    /**
        * Validate the volume
        * @param volume The volume
        */
    export function validateVolume(volume: number): void;
    /**
        * Validate the seconds
        * @param seconds The seconds
        */
    export function validateSeconds(seconds: number): void;
    /**
        * Validate the url or location
        * @param urlOrLocation The url or location
        */
    export function validateUrlOrLocation(urlOrLocation: string): void;
    /**
        * Validate the source type
        * @param sourceType The source type
        */
    export function validateSourceType(sourceType: number): void;
    export function validatePlayer(player: AudioPlayer, where: string): void;
}

declare module 'discord-media-player/dist/validation/CacheValidation' {
    import type { CacheOptions } from "discord-media-player/dist/cache/Cache";
    import { Resource } from "discord-media-player/dist/util/Resource";
    import { opus } from "prism-media";
    /**
        * Validate the cache directory
        * @param dir The cache directory
        */
    export function validateDir(dir: string): void;
    /**
        * Validate the cache options
        * @param options The cache options
        */
    export function validateOptions(options: CacheOptions): void;
    /**
        * Validate the cache identifier
        * @param identifier The cache identifier
        */
    export function validateIdentifier(identifier: string): void;
    /**
        * Validate the cache resource
        * @param resource The cache resource
        */
    export function validateResource(resource: Resource): void;
    /**
        * Validate the seconds
        * @param seconds Where to start the audio (in seconds)
        */
    export function validateSeconds(seconds: number): void;
    export function validateDecoder(decoder: opus.Decoder): void;
}

declare module 'discord-media-player/dist/validation/CacheManagerValidation' {
    export function validatePath(path: string): void;
    export function validateTimeout(timeout: number): void;
}

declare module 'discord-media-player/dist/validation/CacheWriterValidation' {
    import { Resource } from "discord-media-player/dist/util/Resource";
    import { Cache } from "discord-media-player/dist/cache/Cache";
    export function validateResource(resource: Resource): void;
    export function validateCache(cache: Cache): void;
}

declare module 'discord-media-player/dist/validation/ResourceValidation' {
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    import { ResourceOptions } from "discord-media-player/dist/util/Resource";
    export function validateOptions(options: ResourceOptions): void;
    export function validatePlayer(player: AudioPlayer): void;
    export function validatePaused(paused: boolean): void;
}

declare module 'discord-media-player/dist/validation/SkipperValidation' {
    import { CacheWriter } from "discord-media-player/dist/cache/CacheWriter";
    export function validateSeconds(seconds: number): void;
    export function validateCacheWriter(cacheWriter: CacheWriter): void;
}

declare module 'discord-media-player/dist/validation/QueueManagerValidation' {
    import type { AudioManager } from "discord-media-player/dist/audio/AudioManager";
    import type { youtubeSearchOptions, soundcloudSearchOptions } from "discord-media-player/dist/queue";
    import { VoiceConnection } from "@discordjs/voice";
    export function validateAudioManager(audioManager: AudioManager): void;
    export function validateConnection(connection: VoiceConnection): void;
    export function validateYoutubeSearchOptions(options: youtubeSearchOptions): void;
    export function validateSoundcloudSearchOptions(options: soundcloudSearchOptions): void;
}

declare module 'discord-media-player/dist/validation/QueueHandlerValidation' {
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    import { QueueManager } from "discord-media-player/dist/queue";
    export function validateManager<TM extends object>(manager: QueueManager<TM>): void;
    export function validatePlayer(player: AudioPlayer): void;
}

declare module 'discord-media-player/dist/validation/QueueValidation' {
    import { Track } from "discord-media-player/dist/queue";
    export function validateTrack<TM extends object>(track: Track<TM>): void;
    export function validateRemove(what: string, value: number): void;
}

declare module 'discord-media-player/dist/validation/TrackValidation' {
    import type { TrackResolvable } from "discord-media-player/dist/queue";
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    export function validateTrack<TM extends object>(track: TrackResolvable<TM>): void;
    export function validateNumber(where: string, value: number): void;
    export function validatePlayer(player: AudioPlayer): void;
}

declare module 'discord-media-player/dist/validation/PacketReaderValidation' {
    import type { Packet } from "discord-media-player/dist/cache/PacketReader";
    export function validatePackets(packets: Array<Packet>): void;
}

declare module 'discord-media-player/dist/validation/CacheReaderValidation' {
    import type { Packet } from "discord-media-player/dist/cache/PacketReader";
    import { FileHandle } from "fs/promises";
    export function validatePackets(packets: Array<Packet>): void;
    export function validateFileHandle(fileHandle: Promise<FileHandle>): void;
    export function validateMs(ms: number): void;
    export function validateFile(file: FileHandle): void;
}

declare module 'discord-media-player/dist/queue/QueueManager' {
    import type { VoiceConnection } from "@discordjs/voice";
    import type { TrackInfo as SCDLTrackInfo } from "soundcloud-downloader/src/info";
    import type { AudioManagerOptions, AudioManagerEvents } from "discord-media-player/dist/audio/AudioManager";
    import type { PlaylistVideo, YoutubeSearchVideoInfo, YoutubeVideoDetails } from "youtube-scrapper";
    import { Track } from "discord-media-player/dist/queue/Track";
    import { QueueHandler } from "discord-media-player/dist/queue/QueueHandler";
    import { TypedEmitter } from "tiny-typed-emitter";
    import { AudioManager } from "discord-media-player/dist/audio/AudioManager";
    /**
        * A RegExp instance to identify youtube playlist url
        */
    export const PLAYLIST_URL: RegExp;
    /**
        * A RegExp instance to identify youtube video url
        */
    export const VIDEO_URL: RegExp;
    /**
        * Track metadata of youtube search result
        */
    export type youtubeMetadata = PlaylistVideo | YoutubeSearchVideoInfo | YoutubeVideoDetails;
    /**
        * Track metadata of soundcloud search result
        */
    export type soundcloudMetadata = SCDLTrackInfo;
    /**
        * The youtube search result type
        */
    export type youtubeSearchResultType = "video" | "playlist" | "search";
    /**
        * The soundcloud search result type
        */
    export type soundcloudSearchResultType = "track" | "set" | "search";
    /**
        * The youtube video types
        */
    export interface youtubeVideoType {
            video: YoutubeVideoDetails;
            playlist: PlaylistVideo;
            search: YoutubeSearchVideoInfo;
    }
    /**
        * The youtube search options
        */
    export interface youtubeSearchOptions {
            query: string;
            fullPlaylist?: boolean;
    }
    /**
        * The soundcloud search options
        */
    export interface soundcloudSearchOptions {
            query: string;
            searchLimit?: number;
            searchOffset?: number;
            setLimit?: number;
    }
    /**
        * The youtube search result
        */
    export interface youtubeSearchResult<T extends youtubeSearchResultType> {
            type: T;
            tracks: Track<youtubeVideoType[T]>[];
    }
    /**
        * The soundcloud search result
        */
    export interface soundcloudSearchResult {
            type: soundcloudSearchResultType;
            tracks: Track<soundcloudMetadata>[];
    }
    /**
        * The AudioManager-like that can be passed to queue manager
        */
    export type AudioManagerResolvable = AudioManager | AudioManagerOptions;
    export interface QueueManagerEvents {
            /**
                * {@link AudioManagerEvents.audioStart | AudioStartCallback}
                */
            audioStart: AudioManagerEvents["audioStart"];
            /**
                * {@link AudioManagerEvents.audioEnd | AudioEndCallback}
                */
            audioEnd: AudioManagerEvents["audioEnd"];
            /**
                * {@link AudioManagerEvents.audioError | AudioErrorCallback}
                */
            audioError: AudioManagerEvents["audioError"];
            /**
                * @param guildID The guildID of the linked connection in queue player
                */
            queueStart(guildID: string): void;
            /**
                * @param guildID The guildID of the linked connection in queue player
                */
            queueEnd(guildID: string): void;
    }
    /**
        * The manager of queue handler
        *
        * Example:
        * ```ts
        * import { QueueManager, CacheManagerImpl, youtubeMetadata, soundcloudMetadata } from "discord-media-player"
        * const manager = new QueueManager<youtubeMetadata | soundcloudMetadata>({
        *   //cache is optional
        *   cache: new CacheManagerImpl()
        * })
        * ...
        * ```
        */
    export class QueueManager<TM extends object = {}, M = unknown> extends TypedEmitter<QueueManagerEvents> {
            /**
                * Emitted whenever an audio is started playing
                *
                * Listener must implement {@link AudioManagerEvents.audioStart | AudioStartCallback}
                * @event
                */
            static AUDIO_START: string;
            /**
                * Emitted whenever an audio is ended after playing
                *
                * Listener must implement {@link AudioManagerEvents.audioEnd | AudioEndCallback}
                * @event
                */
            static AUDIO_END: string;
            /**
                * Emitted whenever an error is thrown while getting audio source before playing
                *
                * Listener must implement {@link AudioManagerEvents.audioError | AudioErrorCallback}
                * @event
                */
            static AUDIO_ERROR: string;
            /**
                * Emitted whenever a queue is starting to play audio
                *
                * Listener must implement {@link QueueManagerEvents.queueStart | QueueStartCallback}
                * @event
                */
            static QUEUE_START: string;
            /**
                * Emitted whenever a queue is ended
                *
                * Listener must implement {@link QueueManagerEvents.queueEnd | QueueEndCallback}
                * @event
                */
            static QUEUE_END: string;
            /**
                * The audio manager of the queue
                */
            readonly audioManager: AudioManager;
            /**
                * The queue manager metadata (if any)
                */
            readonly metadata?: M;
            /**
                * @param manager The audio manager resolvable
                */
            constructor(manager: AudioManagerResolvable, metadata?: M);
            /**
                * Get queue handler from list if exist, otherwise create new
                * @param connection The voice connection
                * @returns The queue handler
                */
            getHandler(connection: VoiceConnection): QueueHandler<TM>;
            /**
                * Delete queue handler from list
                * @param connection The voice connection
                * @returns false if failed or doesn't exist, true if deleted
                */
            deleteHandler(connection: VoiceConnection): boolean;
            /**
                * @internal
                */
            _deleteHandlerIfExist(guildID: string): void;
            /**
                * Search for a youtube track
                * @param options The youtube search options
                * @returns The youtube search result
                */
            youtubeSearch(options: youtubeSearchOptions): Promise<youtubeSearchResult<youtubeSearchResultType>>;
            /**
                * Search for a soundcloud track
                * @param options The soundcloud search options
                * @returns The soundcloud search result
                */
            soundcloudSearch(options: soundcloudSearchOptions): Promise<soundcloudSearchResult>;
    }
}

declare module 'discord-media-player/dist/queue/QueueHandler' {
    import type { Filters } from "discord-media-player/dist/util/Filters";
    import type { QueueManager } from "discord-media-player/dist/queue/QueueManager";
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    import type { AudioPlayerStatus } from "@discordjs/voice";
    import { Queue } from "discord-media-player/dist/queue/Queue";
    /**
        * The instance to handle audio player and queue
        */
    export class QueueHandler<TM extends object = {}> {
            /**
                * The manager of the queue handler
                */
            readonly manager: QueueManager<TM>;
            /**
                * The handled queue
                */
            readonly queue: Queue<TM>;
            /**
                * @param manager The queue manager
                * @param player The handled audio player
                */
            constructor(manager: QueueManager<TM>, player: AudioPlayer);
            /**
                * The player linked connection guildID
                */
            get guildID(): string;
            /**
                * The audio player status
                */
            get status(): AudioPlayerStatus;
            /**
                * The audio player is playing or not
                */
            get playing(): boolean;
            /**
                * The audio volume
                */
            get volume(): number;
            /**
                * The audio player is looping the current audio or not
                */
            get looping(): boolean;
            /**
                * The queue is looped or not
                */
            get queueLooping(): boolean;
            /**
                * The current track is paused or not
                */
            get paused(): boolean;
            /**
                * The audio is filtered or not
                */
            get filtered(): boolean;
            /**
                * Set the volume of the audio
                * @param volume The volume
                */
            setVolume(volume: number): void;
            /**
                * Loop the current audio
                * @returns true if looping, otherwise false
                */
            loop(): boolean;
            /**
                * Loop the queue
                * @returns true if looping, otherwise false
                */
            loopQueue(): boolean;
            /**
                * Pause the current track
                * @returns true if paused, otherwise false
                */
            pause(): boolean;
            /**
                * Filter the audio
                * @param filters The filters (ffmpeg-audiofilters)
                */
            filter(filters: Filters): void;
            /**
                * If the audio is filtered, unfilter the audio
                */
            unfilter(): void;
            /**
                * Stop the current track
                */
            stop(): void;
            /**
                * Seek into specific duration of the current track
                * @param seconds Where to seek (in seconds)
                */
            seek(seconds: number): Promise<void>;
            /**
                * Start the queue cycle
                */
            play(): Promise<void>;
    }
}

declare module 'discord-media-player/dist/queue/Queue' {
    import type { Track } from "discord-media-player/dist/queue/Track";
    /**
        * Queue instance of tracks to play
        *
        * The current playing track is provided in
        * ```js
        * Queue.current
        * ```
        * and not in
        * ```js
        * Queue[0]
        * ```
        */
    export class Queue<TM extends object = {}> extends Array<Track<TM>> {
            /**
                * The current playing track
                */
            current?: Track<TM>;
            /**
                * Add some tracks into the queue
                * @param tracks The tracks
                * @returns The queue
                */
            add(tracks: Track<TM> | Track<TM>[]): this;
            /**
                * Remove tracks by position in queue (excluding current)
                * @param position Starting position to delete
                * @param howMany How many to delete starting from position
                * @returns The queue
                */
            remove(position: number, howMany?: number): this;
            /**
                * Progress the first track as current track
                * @returns The queue
                */
            progress(): this;
            /**
                * Clear the tracks in the queue
                * @returns The queue
                */
            clear(): this;
    }
}

declare module 'discord-media-player/dist/queue/Track' {
    import type { AudioPlayer } from "discord-media-player/dist/audio/AudioPlayer";
    const kTrack: unique symbol;
    const kPlayer: unique symbol;
    const kPauses: unique symbol;
    const kUnpauses: unique symbol;
    /**
        * Raw object of the track
        */
    export interface TrackResolvable<TM extends object = {}> {
            sourceType: number;
            urlOrLocation: string;
            metadata?: TM;
    }
    /**
        * Track instance of the raw track
        */
    export class Track<TM extends object = {}> {
            /**
                * @param track The raw track object
                */
            constructor(track: TrackResolvable<TM>);
            /**
                * The track source type
                */
            get sourceType(): number;
            /**
                * The track url or location
                */
            get urlOrLocation(): string;
            /**
                * The playback duration of the track (if playing)
                */
            get playbackDuration(): number;
            /**
                * The paused duration of the track (if playing and paused atleast once)
                */
            get pausedDuration(): number;
            /**
                * Get value of a track metadata property
                * @param key The metadata property key
                * @returns The metadata property value
                */
            get<K extends keyof TM>(key: K): TM[K];
            /**
                * Set a value to a track metadata property
                * @param key The metadata property key
                * @param value The metadata property value to set
                */
            set<K extends keyof TM, V extends TM[K]>(key: K, value: V): void;
            /**
                * Set the audio player which play the track
                * @param player The audio player
                */
            setPlayer(player: AudioPlayer): void;
            /**
                * Add a pause timestamp when track is paused
                * @param timestamp The timestamp when the track is paused
                */
            addPausedTimestamp(timestamp: number): void;
            /**
                * Add a unpause timestamp when track is unpaused
                * @param timestamp The timestamp when the track is unpaused
                */
            addUnpausedTimestamp(timestamp: number): void;
            /**
                * Cleanup timestamps after track is stopped playing
                */
            cleanup(): void;
    }
    export {};
}

